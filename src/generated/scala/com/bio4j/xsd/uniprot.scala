// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package com.bio4j.xsd


case class Uniprot(entry: Seq[com.bio4j.xsd.Entry] = Nil,
  copyright: Option[String] = None)
      

trait Dataset

object Dataset {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Dataset = value match {
    case "Swiss-Prot" => Swissu45Prot
    case "TrEMBL" => TrEMBL

  }
}

case object Swissu45Prot extends Dataset { override def toString = "Swiss-Prot" }
case object TrEMBL extends Dataset { override def toString = "TrEMBL" }


case class Entry(accession: Seq[String] = Nil,
  name: Seq[String] = Nil,
  protein: com.bio4j.xsd.ProteinType,
  gene: Seq[com.bio4j.xsd.GeneType] = Nil,
  organism: com.bio4j.xsd.OrganismType,
  organismHost: Seq[com.bio4j.xsd.OrganismType] = Nil,
  geneLocation: Seq[com.bio4j.xsd.GeneLocationType] = Nil,
  reference: Seq[com.bio4j.xsd.ReferenceType] = Nil,
  comment: Seq[Option[com.bio4j.xsd.CommentType]] = Nil,
  dbReference: Seq[com.bio4j.xsd.DbReferenceType] = Nil,
  proteinExistence: com.bio4j.xsd.ProteinExistenceType,
  keyword: Seq[com.bio4j.xsd.KeywordType] = Nil,
  feature: Seq[com.bio4j.xsd.FeatureType] = Nil,
  evidence: Seq[com.bio4j.xsd.EvidenceType] = Nil,
  sequence: com.bio4j.xsd.SequenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val dataset = attributes("@dataset").as[Dataset]
  lazy val created = attributes("@created").as[javax.xml.datatype.XMLGregorianCalendar]
  lazy val modified = attributes("@modified").as[javax.xml.datatype.XMLGregorianCalendar]
  lazy val version = attributes("@version").as[Int]
}

      


case class Domain(proteinNameGroupSequence1: com.bio4j.xsd.ProteinNameGroupSequence)
      


case class Component(proteinNameGroupSequence1: com.bio4j.xsd.ProteinNameGroupSequence)
      


/** Describes the names for the protein and parts thereof.
            Equivalent to the flat file DE-line.
*/
case class ProteinType(proteinNameGroupSequence1: com.bio4j.xsd.ProteinNameGroupSequence,
  domain: Seq[com.bio4j.xsd.Domain] = Nil,
  component: Seq[com.bio4j.xsd.Component] = Nil)
      


case class RecommendedName(fullName: com.bio4j.xsd.EvidencedStringType,
  shortName: Seq[com.bio4j.xsd.EvidencedStringType] = Nil,
  ecNumber: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)
      


case class AlternativeName(fullName: Option[com.bio4j.xsd.EvidencedStringType] = None,
  shortName: Seq[com.bio4j.xsd.EvidencedStringType] = Nil,
  ecNumber: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)
      


case class SubmittedName(fullName: com.bio4j.xsd.EvidencedStringType,
  ecNumber: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)
      


/** Describes a gene.
            Equivalent to the flat file GN-line.
*/
case class GeneType(name: Seq[com.bio4j.xsd.GeneNameType] = Nil)
      

trait Type

object Type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Type = value match {
    case "primary" => Primary
    case "synonym" => Synonym
    case "ordered locus" => Orderedlocus
    case "ORF" => ORF

  }
}

case object Primary extends Type { override def toString = "primary" }
case object Synonym extends Type { override def toString = "synonym" }
case object Orderedlocus extends Type { override def toString = "ordered locus" }
case object ORF extends Type { override def toString = "ORF" }


/** Describes different types of gene designations.
            Equivalent to the flat file GN-line.
*/
case class GeneNameType(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
  lazy val typeValue = attributes("@type").as[Type]
}

      


case class Lineage(taxon: Seq[String] = Nil)
      


/** Describes the source organism.
*/
case class OrganismType(name: Seq[com.bio4j.xsd.OrganismNameType] = Nil,
  dbReference: Seq[com.bio4j.xsd.DbReferenceType] = Nil,
  lineage: Option[com.bio4j.xsd.Lineage] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      

trait TypeType

object TypeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType = value match {
    case "common" => Common
    case "full" => Full
    case "scientific" => Scientific
    case "synonym" => SynonymValue
    case "abbreviation" => Abbreviation

  }
}

case object Common extends TypeType { override def toString = "common" }
case object Full extends TypeType { override def toString = "full" }
case object Scientific extends TypeType { override def toString = "scientific" }
case object SynonymValue extends TypeType { override def toString = "synonym" }
case object Abbreviation extends TypeType { override def toString = "abbreviation" }


/** Describes different types of source organism names.
*/
case class OrganismNameType(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[TypeType]
}

      

trait TypeType2

object TypeType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType2 = value match {
    case "apicoplast" => Apicoplast
    case "chloroplast" => Chloroplast
    case "organellar chromatophore" => Organellarchromatophore
    case "cyanelle" => Cyanelle
    case "hydrogenosome" => Hydrogenosome
    case "mitochondrion" => Mitochondrion
    case "non-photosynthetic plastid" => Nonu45photosyntheticplastid
    case "nucleomorph" => Nucleomorph
    case "plasmid" => PlasmidValue
    case "plastid" => Plastid

  }
}

case object Apicoplast extends TypeType2 { override def toString = "apicoplast" }
case object Chloroplast extends TypeType2 { override def toString = "chloroplast" }
case object Organellarchromatophore extends TypeType2 { override def toString = "organellar chromatophore" }
case object Cyanelle extends TypeType2 { override def toString = "cyanelle" }
case object Hydrogenosome extends TypeType2 { override def toString = "hydrogenosome" }
case object Mitochondrion extends TypeType2 { override def toString = "mitochondrion" }
case object Nonu45photosyntheticplastid extends TypeType2 { override def toString = "non-photosynthetic plastid" }
case object Nucleomorph extends TypeType2 { override def toString = "nucleomorph" }
case object PlasmidValue extends TypeType2 { override def toString = "plasmid" }
case object Plastid extends TypeType2 { override def toString = "plastid" }


/** Describes non-nuclear gene locations (organelles and plasmids).
            Equivalent to the flat file OG-line.
*/
case class GeneLocationType(name: Seq[com.bio4j.xsd.StatusType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[TypeType2]
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      

trait Status

object Status {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Status = value match {
    case "known" => Known
    case "unknown" => Unknown

  }
}

case object Known extends Status { override def toString = "known" }
case object Unknown extends Status { override def toString = "unknown" }


/** Indicates whether the name of a plasmid is known or unknown.
*/
case class StatusType(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val status = attributes("@status").as[Status]
}

      


/** Describes a citation and a summary of its content.
            Equivalent to the flat file RN-, RP-, RC-, RX-, RG-, RA-, RT- and RL-lines.
*/
case class ReferenceType(citation: com.bio4j.xsd.CitationType,
  sptrCitationGroupSequence2: com.bio4j.xsd.SptrCitationGroupSequence,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
  lazy val key = attributes("@key").as[String]
}

      

trait TypeType3

object TypeType3 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType3 = value match {
    case "book" => Book
    case "journal article" => Journalarticle
    case "online journal article" => Onlinejournalarticle
    case "patent" => Patent
    case "submission" => Submission
    case "thesis" => Thesis
    case "unpublished observations" => Unpublishedobservations

  }
}

case object Book extends TypeType3 { override def toString = "book" }
case object Journalarticle extends TypeType3 { override def toString = "journal article" }
case object Onlinejournalarticle extends TypeType3 { override def toString = "online journal article" }
case object Patent extends TypeType3 { override def toString = "patent" }
case object Submission extends TypeType3 { override def toString = "submission" }
case object Thesis extends TypeType3 { override def toString = "thesis" }
case object Unpublishedobservations extends TypeType3 { override def toString = "unpublished observations" }


/** Describes different types of citations.
            Equivalent to the flat file RX-, RG-, RA-, RT- and RL-lines.
*/
case class CitationType(title: Option[String] = None,
  editorList: Option[com.bio4j.xsd.NameListType] = None,
  authorList: Option[com.bio4j.xsd.NameListType] = None,
  locator: Option[String] = None,
  dbReference: Seq[com.bio4j.xsd.DbReferenceType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[TypeType3]
  lazy val date = attributes.get("@date") map { _.as[String] }
  lazy val name = attributes.get("@name") map { _.as[String] }
  lazy val volume = attributes.get("@volume") map { _.as[String] }
  lazy val first = attributes.get("@first") map { _.as[String] }
  lazy val last = attributes.get("@last") map { _.as[String] }
  lazy val publisher = attributes.get("@publisher") map { _.as[String] }
  lazy val city = attributes.get("@city") map { _.as[String] }
  lazy val db = attributes.get("@db") map { _.as[String] }
  lazy val number = attributes.get("@number") map { _.as[String] }
  lazy val institute = attributes.get("@institute") map { _.as[String] }
  lazy val country = attributes.get("@country") map { _.as[String] }
}

      


/** Describes the authors of a citation when these are represented by a consortium.
            Equivalent to the flat file RG-line.
*/
case class ConsortiumType(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NameListTypeOption {
  lazy val name = attributes("@name").as[String]
}

      


case class PersonType(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NameListTypeOption {
  lazy val name = attributes("@name").as[String]
}

      


case class NameListType(namelisttypeoption: Seq[scalaxb.DataRecord[com.bio4j.xsd.NameListTypeOption]] = Nil)
      

trait NameListTypeOption

case class Strain(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends SourceDataTypeOption {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      


case class Plasmid(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends SourceDataTypeOption {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      


case class Transposon(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends SourceDataTypeOption {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      


case class Tissue(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends SourceDataTypeOption {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      


/** Describes the source of the sequence according to the citation.
            Equivalent to the flat file RC-line.
*/
case class SourceDataType(sourcedatatypeoption: Seq[scalaxb.DataRecord[com.bio4j.xsd.SourceDataTypeOption]] = Nil)
      

trait SourceDataTypeOption
trait TypeType4

object TypeType4 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType4 = value match {
    case "allergen" => Allergen
    case "alternative products" => Alternativeproducts
    case "biotechnology" => Biotechnology
    case "biophysicochemical properties" => Biophysicochemicalproperties
    case "catalytic activity" => Catalyticactivity
    case "caution" => Caution
    case "cofactor" => Cofactor
    case "developmental stage" => Developmentalstage
    case "disease" => DiseaseValue
    case "domain" => DomainValue
    case "disruption phenotype" => Disruptionphenotype
    case "enzyme regulation" => Enzymeregulation
    case "function" => FunctionType
    case "induction" => Induction
    case "miscellaneous" => Miscellaneous
    case "pathway" => Pathway
    case "pharmaceutical" => Pharmaceutical
    case "polymorphism" => Polymorphism
    case "PTM" => PTM
    case "RNA editing" => RNAediting
    case "similarity" => Similarity
    case "subcellular location" => Subcellularlocation
    case "sequence caution" => Sequencecaution
    case "subunit" => Subunit
    case "tissue specificity" => Tissuespecificity
    case "toxic dose" => Toxicdose
    case "online information" => Onlineinformation
    case "mass spectrometry" => Massspectrometry
    case "interaction" => Interaction

  }
}

case object Allergen extends TypeType4 { override def toString = "allergen" }
case object Alternativeproducts extends TypeType4 { override def toString = "alternative products" }
case object Biotechnology extends TypeType4 { override def toString = "biotechnology" }
case object Biophysicochemicalproperties extends TypeType4 { override def toString = "biophysicochemical properties" }
case object Catalyticactivity extends TypeType4 { override def toString = "catalytic activity" }
case object Caution extends TypeType4 { override def toString = "caution" }
case object Cofactor extends TypeType4 { override def toString = "cofactor" }
case object Developmentalstage extends TypeType4 { override def toString = "developmental stage" }
case object DiseaseValue extends TypeType4 { override def toString = "disease" }
case object DomainValue extends TypeType4 { override def toString = "domain" }
case object Disruptionphenotype extends TypeType4 { override def toString = "disruption phenotype" }
case object Enzymeregulation extends TypeType4 { override def toString = "enzyme regulation" }
case object FunctionType extends TypeType4 { override def toString = "function" }
case object Induction extends TypeType4 { override def toString = "induction" }
case object Miscellaneous extends TypeType4 { override def toString = "miscellaneous" }
case object Pathway extends TypeType4 { override def toString = "pathway" }
case object Pharmaceutical extends TypeType4 { override def toString = "pharmaceutical" }
case object Polymorphism extends TypeType4 { override def toString = "polymorphism" }
case object PTM extends TypeType4 { override def toString = "PTM" }
case object RNAediting extends TypeType4 { override def toString = "RNA editing" }
case object Similarity extends TypeType4 { override def toString = "similarity" }
case object Subcellularlocation extends TypeType4 { override def toString = "subcellular location" }
case object Sequencecaution extends TypeType4 { override def toString = "sequence caution" }
case object Subunit extends TypeType4 { override def toString = "subunit" }
case object Tissuespecificity extends TypeType4 { override def toString = "tissue specificity" }
case object Toxicdose extends TypeType4 { override def toString = "toxic dose" }
case object Onlineinformation extends TypeType4 { override def toString = "online information" }
case object Massspectrometry extends TypeType4 { override def toString = "mass spectrometry" }
case object Interaction extends TypeType4 { override def toString = "interaction" }

trait TypeType5

object TypeType5 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType5 = value match {
    case "frameshift" => Frameshift
    case "erroneous initiation" => Erroneousinitiation
    case "erroneous termination" => Erroneoustermination
    case "erroneous gene model prediction" => Erroneousgenemodelprediction
    case "erroneous translation" => Erroneoustranslation
    case "miscellaneous discrepancy" => Miscellaneousdiscrepancy

  }
}

case object Frameshift extends TypeType5 { override def toString = "frameshift" }
case object Erroneousinitiation extends TypeType5 { override def toString = "erroneous initiation" }
case object Erroneoustermination extends TypeType5 { override def toString = "erroneous termination" }
case object Erroneousgenemodelprediction extends TypeType5 { override def toString = "erroneous gene model prediction" }
case object Erroneoustranslation extends TypeType5 { override def toString = "erroneous translation" }
case object Miscellaneousdiscrepancy extends TypeType5 { override def toString = "miscellaneous discrepancy" }

trait Resource

object Resource {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Resource = value match {
    case "EMBL-CDS" => EMBLu45CDS
    case "EMBL" => EMBL

  }
}

case object EMBLu45CDS extends Resource { override def toString = "EMBL-CDS" }
case object EMBL extends Resource { override def toString = "EMBL" }


case class Sequence(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val resource = attributes("@resource").as[Resource]
  lazy val id = attributes("@id").as[String]
  lazy val version = attributes.get("@version") map { _.as[Int] }
}

      


case class Conflict(sequence: Option[com.bio4j.xsd.Sequence] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends CommentTypeOption {
  lazy val typeValue = attributes("@type").as[TypeType5]
  lazy val ref = attributes.get("@ref") map { _.as[String] }
}

      


case class Link(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val uri = attributes("@uri").as[java.net.URI]
}

      


case class Disease(name: String,
  acronym: String,
  description: String,
  dbReference: com.bio4j.xsd.DbReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends CommentTypeOption {
  lazy val id = attributes("@id").as[String]
}

      


/** Describes different types of general annotations.
            Equivalent to the flat file CC-line.
*/
case class CommentType(molecule: Option[com.bio4j.xsd.MoleculeType] = None,
  commenttypeoption: Option[scalaxb.DataRecord[Any]] = None,
  location: Seq[com.bio4j.xsd.LocationType] = Nil,
  text: Seq[com.bio4j.xsd.EvidencedStringType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[TypeType4]
  lazy val locationType = attributes.get("@locationType") map { _.as[String] }
  lazy val name = attributes.get("@name") map { _.as[String] }
  lazy val mass = attributes.get("@mass") map { _.as[Float] }
  lazy val error = attributes.get("@error") map { _.as[String] }
  lazy val method = attributes.get("@method") map { _.as[String] }
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      

case class CommentTypeSequence4(event: Seq[com.bio4j.xsd.EventType] = Nil,
  isoform: Seq[com.bio4j.xsd.IsoformType] = Nil) extends CommentTypeOption

trait CommentTypeOption
case class CommentTypeSequence3(link: com.bio4j.xsd.Link*) extends CommentTypeOption
case class CommentTypeSequence5(interactant: Seq[com.bio4j.xsd.InteractantType] = Nil,
  organismsDiffer: Boolean,
  experiments: Int) extends CommentTypeOption

case class CommentTypeSequence1(cofactor: com.bio4j.xsd.CofactorType*) extends CommentTypeOption
case class CommentTypeSequence2(subcellularLocation: com.bio4j.xsd.SubcellularLocationType*) extends CommentTypeOption

case class Absorption(max: Option[com.bio4j.xsd.EvidencedStringType] = None,
  text: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)
      


case class Kinetics(KM: Seq[com.bio4j.xsd.EvidencedStringType] = Nil,
  Vmax: Seq[com.bio4j.xsd.EvidencedStringType] = Nil,
  text: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)
      


case class PhDependence(text: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)
      


case class RedoxPotential(text: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)
      


case class TemperatureDependence(text: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)
      


/** Describes a cofactor.
*/
case class CofactorType(name: String,
  dbReference: com.bio4j.xsd.DbReferenceType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      


/** Describes the subcellular location and optionally the topology and orientation of a molecule.
*/
case class SubcellularLocationType(location: Seq[com.bio4j.xsd.EvidencedStringType] = Nil,
  topology: Seq[com.bio4j.xsd.EvidencedStringType] = Nil,
  orientation: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)
      

trait TypeType6

object TypeType6 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType6 = value match {
    case "alternative splicing" => Alternativesplicing
    case "alternative initiation" => Alternativeinitiation
    case "alternative promoter" => Alternativepromoter
    case "ribosomal frameshifting" => Ribosomalframeshifting

  }
}

case object Alternativesplicing extends TypeType6 { override def toString = "alternative splicing" }
case object Alternativeinitiation extends TypeType6 { override def toString = "alternative initiation" }
case object Alternativepromoter extends TypeType6 { override def toString = "alternative promoter" }
case object Ribosomalframeshifting extends TypeType6 { override def toString = "ribosomal frameshifting" }


/** Describes the type of events that cause alternative products.
*/
case class EventType(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[TypeType6]
}

      


case class Name(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      

trait TypeType7

object TypeType7 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType7 = value match {
    case "not described" => Notdescribed
    case "described" => Described
    case "displayed" => Displayed
    case "external" => External

  }
}

case object Notdescribed extends TypeType7 { override def toString = "not described" }
case object Described extends TypeType7 { override def toString = "described" }
case object Displayed extends TypeType7 { override def toString = "displayed" }
case object External extends TypeType7 { override def toString = "external" }


case class Sequence2(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[TypeType7]
  lazy val ref = attributes.get("@ref") map { _.as[String] }
}

      


/** Describes isoforms in 'alternative products' annotations.
*/
case class IsoformType(id: Seq[String] = Nil,
  name: Seq[com.bio4j.xsd.Name] = Nil,
  sequence: com.bio4j.xsd.Sequence2,
  text: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)
      


case class InteractantType(interactantGroupSequence1: Option[com.bio4j.xsd.InteractantGroupSequence] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val intactId = attributes("@intactId").as[String]
}

      


/** Describes a database cross-reference.
            Equivalent to the flat file DR-line.
            
*/
case class DbReferenceType(molecule: Option[com.bio4j.xsd.MoleculeType] = None,
  property: Seq[com.bio4j.xsd.PropertyType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[String]
  lazy val id = attributes("@id").as[String]
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      


case class PropertyType(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[String]
  lazy val valueAttribute = attributes("@value").as[String]
}

      

trait TypeType8

object TypeType8 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType8 = value match {
    case "evidence at protein level" => Evidenceatproteinlevel
    case "evidence at transcript level" => Evidenceattranscriptlevel
    case "inferred from homology" => Inferredfromhomology
    case "predicted" => Predicted
    case "uncertain" => Uncertain

  }
}

case object Evidenceatproteinlevel extends TypeType8 { override def toString = "evidence at protein level" }
case object Evidenceattranscriptlevel extends TypeType8 { override def toString = "evidence at transcript level" }
case object Inferredfromhomology extends TypeType8 { override def toString = "inferred from homology" }
case object Predicted extends TypeType8 { override def toString = "predicted" }
case object Uncertain extends TypeType8 { override def toString = "uncertain" }


/** Describes the evidence for the protein's existence.
            Equivalent to the flat file PE-line.
*/
case class ProteinExistenceType(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[TypeType8]
}

      


case class KeywordType(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
  lazy val id = attributes("@id").as[String]
}

      

trait TypeType9

object TypeType9 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType9 = value match {
    case "active site" => Activesite
    case "binding site" => Bindingsite
    case "calcium-binding region" => Calciumu45bindingregion
    case "chain" => Chain
    case "coiled-coil region" => Coiledu45coilregion
    case "compositionally biased region" => Compositionallybiasedregion
    case "cross-link" => Crossu45link
    case "disulfide bond" => Disulfidebond
    case "DNA-binding region" => DNAu45bindingregion
    case "domain" => DomainValue2
    case "glycosylation site" => Glycosylationsite
    case "helix" => Helix
    case "initiator methionine" => Initiatormethionine
    case "lipid moiety-binding region" => Lipidmoietyu45bindingregion
    case "metal ion-binding site" => Metalionu45bindingsite
    case "modified residue" => Modifiedresidue
    case "mutagenesis site" => Mutagenesissite
    case "non-consecutive residues" => Nonu45consecutiveresidues
    case "non-terminal residue" => Nonu45terminalresidue
    case "nucleotide phosphate-binding region" => Nucleotidephosphateu45bindingregion
    case "peptide" => Peptide
    case "propeptide" => Propeptide
    case "region of interest" => Regionofinterest
    case "repeat" => Repeat
    case "non-standard amino acid" => Nonu45standardaminoacid
    case "sequence conflict" => Sequenceconflict
    case "sequence variant" => Sequencevariant
    case "short sequence motif" => Shortsequencemotif
    case "signal peptide" => Signalpeptide
    case "site" => Site
    case "splice variant" => Splicevariant
    case "strand" => Strand
    case "topological domain" => Topologicaldomain
    case "transit peptide" => Transitpeptide
    case "transmembrane region" => Transmembraneregion
    case "turn" => Turn
    case "unsure residue" => Unsureresidue
    case "zinc finger region" => Zincfingerregion
    case "intramembrane region" => Intramembraneregion

  }
}

case object Activesite extends TypeType9 { override def toString = "active site" }
case object Bindingsite extends TypeType9 { override def toString = "binding site" }
case object Calciumu45bindingregion extends TypeType9 { override def toString = "calcium-binding region" }
case object Chain extends TypeType9 { override def toString = "chain" }
case object Coiledu45coilregion extends TypeType9 { override def toString = "coiled-coil region" }
case object Compositionallybiasedregion extends TypeType9 { override def toString = "compositionally biased region" }
case object Crossu45link extends TypeType9 { override def toString = "cross-link" }
case object Disulfidebond extends TypeType9 { override def toString = "disulfide bond" }
case object DNAu45bindingregion extends TypeType9 { override def toString = "DNA-binding region" }
case object DomainValue2 extends TypeType9 { override def toString = "domain" }
case object Glycosylationsite extends TypeType9 { override def toString = "glycosylation site" }
case object Helix extends TypeType9 { override def toString = "helix" }
case object Initiatormethionine extends TypeType9 { override def toString = "initiator methionine" }
case object Lipidmoietyu45bindingregion extends TypeType9 { override def toString = "lipid moiety-binding region" }
case object Metalionu45bindingsite extends TypeType9 { override def toString = "metal ion-binding site" }
case object Modifiedresidue extends TypeType9 { override def toString = "modified residue" }
case object Mutagenesissite extends TypeType9 { override def toString = "mutagenesis site" }
case object Nonu45consecutiveresidues extends TypeType9 { override def toString = "non-consecutive residues" }
case object Nonu45terminalresidue extends TypeType9 { override def toString = "non-terminal residue" }
case object Nucleotidephosphateu45bindingregion extends TypeType9 { override def toString = "nucleotide phosphate-binding region" }
case object Peptide extends TypeType9 { override def toString = "peptide" }
case object Propeptide extends TypeType9 { override def toString = "propeptide" }
case object Regionofinterest extends TypeType9 { override def toString = "region of interest" }
case object Repeat extends TypeType9 { override def toString = "repeat" }
case object Nonu45standardaminoacid extends TypeType9 { override def toString = "non-standard amino acid" }
case object Sequenceconflict extends TypeType9 { override def toString = "sequence conflict" }
case object Sequencevariant extends TypeType9 { override def toString = "sequence variant" }
case object Shortsequencemotif extends TypeType9 { override def toString = "short sequence motif" }
case object Signalpeptide extends TypeType9 { override def toString = "signal peptide" }
case object Site extends TypeType9 { override def toString = "site" }
case object Splicevariant extends TypeType9 { override def toString = "splice variant" }
case object Strand extends TypeType9 { override def toString = "strand" }
case object Topologicaldomain extends TypeType9 { override def toString = "topological domain" }
case object Transitpeptide extends TypeType9 { override def toString = "transit peptide" }
case object Transmembraneregion extends TypeType9 { override def toString = "transmembrane region" }
case object Turn extends TypeType9 { override def toString = "turn" }
case object Unsureresidue extends TypeType9 { override def toString = "unsure residue" }
case object Zincfingerregion extends TypeType9 { override def toString = "zinc finger region" }
case object Intramembraneregion extends TypeType9 { override def toString = "intramembrane region" }

trait StatusType2

object StatusType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): StatusType2 = value match {
    case "by similarity" => Bysimilarity
    case "probable" => Probable
    case "potential" => Potential

  }
}

case object Bysimilarity extends StatusType2 { override def toString = "by similarity" }
case object Probable extends StatusType2 { override def toString = "probable" }
case object Potential extends StatusType2 { override def toString = "potential" }


/** Describes different types of sequence annotations.
            Equivalent to the flat file FT-line.
*/
case class FeatureType(original: Option[String] = None,
  variation: Seq[String] = Nil,
  location: com.bio4j.xsd.LocationType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[TypeType9]
  lazy val status = attributes.get("@status") map { _.as[StatusType2] }
  lazy val id = attributes.get("@id") map { _.as[String] }
  lazy val description = attributes.get("@description") map { _.as[String] }
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
  lazy val ref = attributes.get("@ref") map { _.as[String] }
}

      


/** Describes a sequence location as either a range with a begin and end or as a position. The 'sequence' attribute is only used when the location is not on the canonical sequence displayed in the current entry.
*/
case class LocationType(locationtypeoption: scalaxb.DataRecord[com.bio4j.xsd.LocationTypeOption],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val sequence = attributes.get("@sequence") map { _.as[String] }
}

      

trait LocationTypeOption
case class LocationTypeSequence1(begin: com.bio4j.xsd.PositionType,
  end: com.bio4j.xsd.PositionType) extends LocationTypeOption

trait StatusType3

object StatusType3 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): StatusType3 = value match {
    case "certain" => Certain
    case "uncertain" => UncertainValue
    case "less than" => Lessthan
    case "greater than" => Greaterthan
    case "unknown" => UnknownValue

  }
}

case object Certain extends StatusType3 { override def toString = "certain" }
case object UncertainValue extends StatusType3 { override def toString = "uncertain" }
case object Lessthan extends StatusType3 { override def toString = "less than" }
case object Greaterthan extends StatusType3 { override def toString = "greater than" }
case object UnknownValue extends StatusType3 { override def toString = "unknown" }


case class PositionType(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends LocationTypeOption {
  lazy val position = attributes.get("@position") map { _.as[BigInt] }
  lazy val status = attributes("@status").as[StatusType3]
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
}

      

trait Fragment

object Fragment {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Fragment = value match {
    case "single" => Single
    case "multiple" => Multiple

  }
}

case object Single extends Fragment { override def toString = "single" }
case object Multiple extends Fragment { override def toString = "multiple" }


case class SequenceType(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val length = attributes("@length").as[Int]
  lazy val mass = attributes("@mass").as[Int]
  lazy val checksum = attributes("@checksum").as[String]
  lazy val modified = attributes("@modified").as[javax.xml.datatype.XMLGregorianCalendar]
  lazy val version = attributes("@version").as[Int]
  lazy val precursor = attributes.get("@precursor") map { _.as[Boolean] }
  lazy val fragment = attributes.get("@fragment") map { _.as[Fragment] }
}

      


/** Describes a molecule by name or unique identifier.
*/
case class MoleculeType(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val id = attributes.get("@id") map { _.as[String] }
}

      


/** Describes the evidence for an annotation.
            No flat file equivalent.
*/
case class EvidenceType(source: Option[com.bio4j.xsd.SourceType] = None,
  importedFrom: Option[com.bio4j.xsd.ImportedFromType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val typeValue = attributes("@type").as[String]
  lazy val key = attributes("@key").as[BigInt]
}

      


/** Describes the source of the data using a database cross-reference (or a 'ref' attribute when the source cannot be found in a public data source, such as PubMed, and is cited only within the UniProtKB entry).
*/
case class SourceType(dbReference: Option[com.bio4j.xsd.DbReferenceType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val ref = attributes.get("@ref") map { _.as[BigInt] }
}

      


/** Describes the source of the evidence, when it is not assigned by UniProt, but imported from an external database.
*/
case class ImportedFromType(dbReference: com.bio4j.xsd.DbReferenceType)
      

trait StatusType4

object StatusType4 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): StatusType4 = value match {
    case "by similarity" => BysimilarityValue
    case "probable" => ProbableValue
    case "potential" => PotentialValue

  }
}

case object BysimilarityValue extends StatusType4 { override def toString = "by similarity" }
case object ProbableValue extends StatusType4 { override def toString = "probable" }
case object PotentialValue extends StatusType4 { override def toString = "potential" }


case class EvidencedStringType(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val evidence = attributes.get("@evidence") map { _.as[Seq[Int]] }
  lazy val status = attributes.get("@status") map { _.as[StatusType4] }
}

      

case class InteractantGroupSequence(id: String,
  label: Option[String] = None)

case class SptrCitationGroupSequence(scope: Seq[String] = Nil,
  source: Option[com.bio4j.xsd.SourceDataType] = None)

case class ProteinNameGroupSequence(recommendedName: Option[com.bio4j.xsd.RecommendedName] = None,
  alternativeName: Seq[com.bio4j.xsd.AlternativeName] = Nil,
  submittedName: Seq[com.bio4j.xsd.SubmittedName] = Nil,
  allergenName: Option[com.bio4j.xsd.EvidencedStringType] = None,
  biotechName: Option[com.bio4j.xsd.EvidencedStringType] = None,
  cdAntigenName: Seq[com.bio4j.xsd.EvidencedStringType] = Nil,
  innName: Seq[com.bio4j.xsd.EvidencedStringType] = Nil)

case class BpcCommentGroupSequence(absorption: Option[com.bio4j.xsd.Absorption] = None,
  kinetics: Option[com.bio4j.xsd.Kinetics] = None,
  phDependence: Option[com.bio4j.xsd.PhDependence] = None,
  redoxPotential: Option[com.bio4j.xsd.RedoxPotential] = None,
  temperatureDependence: Option[com.bio4j.xsd.TemperatureDependence] = None)

